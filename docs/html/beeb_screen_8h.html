<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beebScreen: beebScreen.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beebScreen
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">PiNativeARM and ARM7TDMI porting library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_528a71a3d9b580428d014896918fb0f0.html">beebScreen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">beebScreen.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>PiNativeArm and ARM7TDMI co-processor support library. beebScreen - A PiNativeArm and ARM7TDMI co-processor support library. This library provides a complete solution for taking an existing C code application or game which uses a linear frame buffer for it's output and converting that output into a format that can be displayed on the BBC Micro's own display.  
<a href="#details">More...</a></p>

<p><a href="beeb_screen_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a13e77d59984347c0b50e54838e4f6d43"><td class="memItemLeft" align="right" valign="top"><a id="a13e77d59984347c0b50e54838e4f6d43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a13e77d59984347c0b50e54838e4f6d43">BS_CMD_SEND_USER1</a>&#160;&#160;&#160;(252)</td></tr>
<tr class="memdesc:a13e77d59984347c0b50e54838e4f6d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Command 1 send using _VDU(BS_CMD_SEND_USER1) <br /></td></tr>
<tr class="separator:a13e77d59984347c0b50e54838e4f6d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b24f4e4519cfa3f7877ba4d283e862"><td class="memItemLeft" align="right" valign="top"><a id="af4b24f4e4519cfa3f7877ba4d283e862"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#af4b24f4e4519cfa3f7877ba4d283e862">BS_CMD_SEND_USER2</a>&#160;&#160;&#160;(251)</td></tr>
<tr class="memdesc:af4b24f4e4519cfa3f7877ba4d283e862"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Command 2 send using _VDU(BS_CMD_SEND_USER2) <br /></td></tr>
<tr class="separator:af4b24f4e4519cfa3f7877ba4d283e862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae192f7137ca0170b80895ef29ceb7313"><td class="memItemLeft" align="right" valign="top"><a id="ae192f7137ca0170b80895ef29ceb7313"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ae192f7137ca0170b80895ef29ceb7313">BS_VECTOR_USER1</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ae192f7137ca0170b80895ef29ceb7313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host side code address to handle User Command 1. <br /></td></tr>
<tr class="separator:ae192f7137ca0170b80895ef29ceb7313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa992215c10df5e9f1958a70399cbedd8"><td class="memItemLeft" align="right" valign="top"><a id="aa992215c10df5e9f1958a70399cbedd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aa992215c10df5e9f1958a70399cbedd8">BS_VECTOR_USER2</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aa992215c10df5e9f1958a70399cbedd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host side code address to handle User Command 2. <br /></td></tr>
<tr class="separator:aa992215c10df5e9f1958a70399cbedd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003314576031f0c9a9081bd8486a2866"><td class="memItemLeft" align="right" valign="top"><a id="a003314576031f0c9a9081bd8486a2866"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a003314576031f0c9a9081bd8486a2866">BS_VECTOR_VSYNC</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a003314576031f0c9a9081bd8486a2866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host side code address for extra VSync code. <br /></td></tr>
<tr class="separator:a003314576031f0c9a9081bd8486a2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace80d01d6e5f8f7372c89053fcf80040"><td class="memItemLeft" align="right" valign="top"><a id="ace80d01d6e5f8f7372c89053fcf80040"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ace80d01d6e5f8f7372c89053fcf80040">BS_VECTOR_TIMER</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ace80d01d6e5f8f7372c89053fcf80040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host side code address for timer interupt handler. <br /></td></tr>
<tr class="separator:ace80d01d6e5f8f7372c89053fcf80040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34767f3322c98972ab0b27577c7670e"><td class="memItemLeft" align="right" valign="top"><a id="aa34767f3322c98972ab0b27577c7670e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aa34767f3322c98972ab0b27577c7670e">MAPRGB</a>(r,  g,  b)&#160;&#160;&#160;(r)+(g&lt;&lt;12)+(b&lt;&lt;8)</td></tr>
<tr class="memdesc:aa34767f3322c98972ab0b27577c7670e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an 12bit RGB value to a NULA colour value. <br /></td></tr>
<tr class="separator:aa34767f3322c98972ab0b27577c7670e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9dba6eaf36aafe87b25d1df43846d6"><td class="memItemLeft" align="right" valign="top"><a id="aca9dba6eaf36aafe87b25d1df43846d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aca9dba6eaf36aafe87b25d1df43846d6">BS_INIT_NORMAL</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:aca9dba6eaf36aafe87b25d1df43846d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">No special flags, normal single buffered mode. <br /></td></tr>
<tr class="separator:aca9dba6eaf36aafe87b25d1df43846d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9f02e1e59043b0b97e93ceeedc04fb"><td class="memItemLeft" align="right" valign="top"><a id="a0a9f02e1e59043b0b97e93ceeedc04fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a0a9f02e1e59043b0b97e93ceeedc04fb">BS_INIT_NULA</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a0a9f02e1e59043b0b97e93ceeedc04fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use VideoNULA for extended palette. <br /></td></tr>
<tr class="separator:a0a9f02e1e59043b0b97e93ceeedc04fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad626fa62b31c0255c8f623ba13ad11d3"><td class="memItemLeft" align="right" valign="top"><a id="ad626fa62b31c0255c8f623ba13ad11d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ad626fa62b31c0255c8f623ba13ad11d3">BS_INIT_DOUBLE_BUFFER</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:ad626fa62b31c0255c8f623ba13ad11d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use double buffering. <br /></td></tr>
<tr class="separator:ad626fa62b31c0255c8f623ba13ad11d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf317e31cc0100962382470f1b3bed8"><td class="memItemLeft" align="right" valign="top"><a id="a0bf317e31cc0100962382470f1b3bed8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a0bf317e31cc0100962382470f1b3bed8">BS_INIT_MOUSE</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a0bf317e31cc0100962382470f1b3bed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable mouse reading. <br /></td></tr>
<tr class="separator:a0bf317e31cc0100962382470f1b3bed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89817fe8b4785728944bd1c31c9887f3"><td class="memItemLeft" align="right" valign="top"><a id="a89817fe8b4785728944bd1c31c9887f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a89817fe8b4785728944bd1c31c9887f3">BS_INIT_ADFS</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a89817fe8b4785728944bd1c31c9887f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ADFS memory on the host. <br /></td></tr>
<tr class="separator:a89817fe8b4785728944bd1c31c9887f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba5e5be97d298fde1c1441d1a9fd6e"><td class="memItemLeft" align="right" valign="top"><a id="a4bba5e5be97d298fde1c1441d1a9fd6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a4bba5e5be97d298fde1c1441d1a9fd6e">BS_INIT_ALL</a>&#160;&#160;&#160;(0xff)</td></tr>
<tr class="memdesc:a4bba5e5be97d298fde1c1441d1a9fd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise everything. <br /></td></tr>
<tr class="separator:a4bba5e5be97d298fde1c1441d1a9fd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48abc47fef7e9f0c9d547741d850fdac"><td class="memItemLeft" align="right" valign="top"><a id="a48abc47fef7e9f0c9d547741d850fdac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a48abc47fef7e9f0c9d547741d850fdac">BS_BUFFER_FORMAT_1BPP</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a48abc47fef7e9f0c9d547741d850fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 Bit per pixel buffer (not uet supported) <br /></td></tr>
<tr class="separator:a48abc47fef7e9f0c9d547741d850fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24a5490dbea84c7d412849e0fa4f20f"><td class="memItemLeft" align="right" valign="top"><a id="ab24a5490dbea84c7d412849e0fa4f20f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ab24a5490dbea84c7d412849e0fa4f20f">BS_BUFFER_FORMAT_2BPP</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:ab24a5490dbea84c7d412849e0fa4f20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 Bits per pixel buffer (not yet supported) <br /></td></tr>
<tr class="separator:ab24a5490dbea84c7d412849e0fa4f20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf25cdaf842b0fb70bc96f2702367bd8"><td class="memItemLeft" align="right" valign="top"><a id="adf25cdaf842b0fb70bc96f2702367bd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#adf25cdaf842b0fb70bc96f2702367bd8">BS_BUFFER_FORMAT_4BPP</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:adf25cdaf842b0fb70bc96f2702367bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 Bits per pixel buffer (not yet supported) <br /></td></tr>
<tr class="separator:adf25cdaf842b0fb70bc96f2702367bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e50ca86421df7cb52ea2ad3f22d813d"><td class="memItemLeft" align="right" valign="top"><a id="a4e50ca86421df7cb52ea2ad3f22d813d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a4e50ca86421df7cb52ea2ad3f22d813d">BS_BUFFER_FORMAT_8BPP</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a4e50ca86421df7cb52ea2ad3f22d813d"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 Bits per pixel buffer <br /></td></tr>
<tr class="separator:a4e50ca86421df7cb52ea2ad3f22d813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dbb911a8b24ea01ef0dba7e7a3e707"><td class="memItemLeft" align="right" valign="top"><a id="a20dbb911a8b24ea01ef0dba7e7a3e707"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a20dbb911a8b24ea01ef0dba7e7a3e707">BS_BUFFER_LITTLE_ENDIAN</a>&#160;&#160;&#160;(128)</td></tr>
<tr class="memdesc:a20dbb911a8b24ea01ef0dba7e7a3e707"><td class="mdescLeft">&#160;</td><td class="mdescRight">For buffers less than 8bpp which order are pixels stored in the buffer, set for lsb on the left (not yet supported) <br /></td></tr>
<tr class="separator:a20dbb911a8b24ea01ef0dba7e7a3e707"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89e526e50914494294f7c2d16c82a1f3"><td class="memItemLeft" align="right" valign="top"><a id="a89e526e50914494294f7c2d16c82a1f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a89e526e50914494294f7c2d16c82a1f3">beebScreen_extractRGB444</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:a89e526e50914494294f7c2d16c82a1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 12bit RGB444 value. <br /></td></tr>
<tr class="separator:a89e526e50914494294f7c2d16c82a1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cdec6cc44f24a88c1f7d1c31efb438"><td class="memItemLeft" align="right" valign="top"><a id="a03cdec6cc44f24a88c1f7d1c31efb438"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a03cdec6cc44f24a88c1f7d1c31efb438">beebScreen_extractRGB555</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:a03cdec6cc44f24a88c1f7d1c31efb438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 15bit RGB555 value. <br /></td></tr>
<tr class="separator:a03cdec6cc44f24a88c1f7d1c31efb438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d86d89d9dc94c7e527276a97f6696b0"><td class="memItemLeft" align="right" valign="top"><a id="a2d86d89d9dc94c7e527276a97f6696b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a2d86d89d9dc94c7e527276a97f6696b0">beebScreen_extractRGB565</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:a2d86d89d9dc94c7e527276a97f6696b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 16bit RGB565 value. <br /></td></tr>
<tr class="separator:a2d86d89d9dc94c7e527276a97f6696b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e689339eb44eae780ae782a55eb746"><td class="memItemLeft" align="right" valign="top"><a id="ab0e689339eb44eae780ae782a55eb746"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ab0e689339eb44eae780ae782a55eb746">beebScreen_extractRGB888</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:ab0e689339eb44eae780ae782a55eb746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 24bit RGB888 value. <br /></td></tr>
<tr class="separator:ab0e689339eb44eae780ae782a55eb746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e042bf14dca6b8cb328b6a308635fa1"><td class="memItemLeft" align="right" valign="top"><a id="a3e042bf14dca6b8cb328b6a308635fa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a3e042bf14dca6b8cb328b6a308635fa1">beebScreen_extractBGR444</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:a3e042bf14dca6b8cb328b6a308635fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 12bit BGR444 value. <br /></td></tr>
<tr class="separator:a3e042bf14dca6b8cb328b6a308635fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f19bfb9256c312d8ee30228bbfb7dd"><td class="memItemLeft" align="right" valign="top"><a id="a48f19bfb9256c312d8ee30228bbfb7dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a48f19bfb9256c312d8ee30228bbfb7dd">beebScreen_extractBGR555</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:a48f19bfb9256c312d8ee30228bbfb7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 15bit BGR555 value. <br /></td></tr>
<tr class="separator:a48f19bfb9256c312d8ee30228bbfb7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa5000319a400b4efa5667db7adcf44"><td class="memItemLeft" align="right" valign="top"><a id="abaa5000319a400b4efa5667db7adcf44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#abaa5000319a400b4efa5667db7adcf44">beebScreen_extractBGR565</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:abaa5000319a400b4efa5667db7adcf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 16bit BGR565 value. <br /></td></tr>
<tr class="separator:abaa5000319a400b4efa5667db7adcf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67603ed582ca4dc5a34e5313bec6549"><td class="memItemLeft" align="right" valign="top"><a id="ad67603ed582ca4dc5a34e5313bec6549"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ad67603ed582ca4dc5a34e5313bec6549">beebScreen_extractBGR888</a> (int v, int *r, int *g, int *b)</td></tr>
<tr class="memdesc:ad67603ed582ca4dc5a34e5313bec6549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts NULA RGB values from a 24bit BGR888 value. <br /></td></tr>
<tr class="separator:ad67603ed582ca4dc5a34e5313bec6549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6133f35081bfe8289f0454d8095934"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#abc6133f35081bfe8289f0454d8095934">beebScreen_FindPalette</a> (int colour, int *remap, int total)</td></tr>
<tr class="separator:abc6133f35081bfe8289f0454d8095934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b8644f8b9f87e01526a90e24bed77c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ac9b8644f8b9f87e01526a90e24bed77c">beebScreen_CreateRemapColours</a> (int *source, int *remap, int total, int len)</td></tr>
<tr class="separator:ac9b8644f8b9f87e01526a90e24bed77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdc30dd9c5a69a947bd2dc2ef849238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a1bdc30dd9c5a69a947bd2dc2ef849238">beebScreen_SetDefaultNulaRemapColours</a> ()</td></tr>
<tr class="separator:a1bdc30dd9c5a69a947bd2dc2ef849238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d19aa39ad7b8e154c57f23bd516ed72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a1d19aa39ad7b8e154c57f23bd516ed72">beebScreen_SetNulaRemapColours</a> (unsigned char *remap)</td></tr>
<tr class="separator:a1d19aa39ad7b8e154c57f23bd516ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaac1547bb293a41b29497e44e2d0dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aaaac1547bb293a41b29497e44e2d0dae">beebScreen_MakeNulaPal</a> (int value, int index, void(*extractor)(int v, int *r, int *g, int *b))</td></tr>
<tr class="separator:aaaac1547bb293a41b29497e44e2d0dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b22300574e3650a3ca27662775d240a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a3b22300574e3650a3ca27662775d240a">beebScreen_SetNulaPal</a> (int *values, int *output, int count, void(*extractor)(int v, int *r, int *g, int *b))</td></tr>
<tr class="separator:a3b22300574e3650a3ca27662775d240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb78b80a1d1b48a39cd9a6f23e934e57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#acb78b80a1d1b48a39cd9a6f23e934e57">beebScreen_CreatePalMap</a> (int *pal, int count, unsigned char *map)</td></tr>
<tr class="separator:acb78b80a1d1b48a39cd9a6f23e934e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21e3b83d7ee0c6540a3cfd08645dc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#af21e3b83d7ee0c6540a3cfd08645dc81">beebScreen_CreateDynamicPalette</a> (int *inPal, unsigned char *palMap, int colours, int *outPal, int target)</td></tr>
<tr class="separator:af21e3b83d7ee0c6540a3cfd08645dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a171863033605e2dec8436d9d1f2778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a2a171863033605e2dec8436d9d1f2778">beebScreen_SendPal</a> (int *pal, int count)</td></tr>
<tr class="separator:a2a171863033605e2dec8436d9d1f2778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ccceb770e35506381522ebe3484c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a46ccceb770e35506381522ebe3484c26">beebScreen_SetMode</a> (int mode)</td></tr>
<tr class="separator:a46ccceb770e35506381522ebe3484c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd5f86ad4d6d4c17e74ee3f6d849f53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a5fd5f86ad4d6d4c17e74ee3f6d849f53">beebScreen_Init</a> (int mode, int flags)</td></tr>
<tr class="separator:a5fd5f86ad4d6d4c17e74ee3f6d849f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48a5346b9833a8ac64770c3f47bca63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#af48a5346b9833a8ac64770c3f47bca63">beebScreen_InjectCode</a> (unsigned char *code, int length, int dest)</td></tr>
<tr class="separator:af48a5346b9833a8ac64770c3f47bca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b0585b650e3039c7e2287498dfc51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a81b0585b650e3039c7e2287498dfc51e">beebScreen_SetUserVector</a> (int vector, int addr)</td></tr>
<tr class="separator:a81b0585b650e3039c7e2287498dfc51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b214a7168d6e7f0b2cf1e796507cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a82b214a7168d6e7f0b2cf1e796507cf8">beebScreen_SetGeometry</a> (int w, int h, int setCrtc)</td></tr>
<tr class="separator:a82b214a7168d6e7f0b2cf1e796507cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce92b3447b64d431066bd4d6e055b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a2ce92b3447b64d431066bd4d6e055b1b">beebScreen_SetScreenBase</a> (int address, int secondBuffer)</td></tr>
<tr class="separator:a2ce92b3447b64d431066bd4d6e055b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3faccb64a04961c67bcd6b47bba3ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a0f3faccb64a04961c67bcd6b47bba3ff">beebScreen_CalcScreenBase</a> (int secondBuffer)</td></tr>
<tr class="separator:a0f3faccb64a04961c67bcd6b47bba3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7552b5cb566badaecb3f578cfe3e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a8a7552b5cb566badaecb3f578cfe3e8b">beebScreen_UseDefaultScreenBases</a> ()</td></tr>
<tr class="separator:a8a7552b5cb566badaecb3f578cfe3e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff38476951488f8802720de1cc2c75ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aff38476951488f8802720de1cc2c75ff">beebScreen_ClearScreens</a> (int screenMemory)</td></tr>
<tr class="separator:aff38476951488f8802720de1cc2c75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16bbfa1824fe755905a30490fcc01f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a5d16bbfa1824fe755905a30490fcc01f">beebScreen_FlipCallback</a> (void(*callback)(void))</td></tr>
<tr class="separator:a5d16bbfa1824fe755905a30490fcc01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac6b2a3d6fd9f93dfe264bd9d34bf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aaac6b2a3d6fd9f93dfe264bd9d34bf6d">beebScreen_SetBuffer</a> (unsigned char *buffer, int format, int w, int h)</td></tr>
<tr class="separator:aaac6b2a3d6fd9f93dfe264bd9d34bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a822c1979c5a7d2361ef13663359655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a9a822c1979c5a7d2361ef13663359655">beebScreen_Flip</a> ()</td></tr>
<tr class="separator:a9a822c1979c5a7d2361ef13663359655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad883835655aacdb8b0c3f5da47164da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ad883835655aacdb8b0c3f5da47164da6">beebScreen_VSync</a> ()</td></tr>
<tr class="separator:ad883835655aacdb8b0c3f5da47164da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae232afaac80a1ab991ad7110d90bdc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#ae232afaac80a1ab991ad7110d90bdc52">beebScreen_Quit</a> ()</td></tr>
<tr class="separator:ae232afaac80a1ab991ad7110d90bdc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45543225bb0fdafe7d329cb8e3c4897a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a45543225bb0fdafe7d329cb8e3c4897a">beebScreen_GetMouse</a> (int *x, int *y, int *b)</td></tr>
<tr class="separator:a45543225bb0fdafe7d329cb8e3c4897a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531c1c4c57be869836c8aac929abf1fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a531c1c4c57be869836c8aac929abf1fa">beebScreen_ShowPointer</a> (int show)</td></tr>
<tr class="separator:a531c1c4c57be869836c8aac929abf1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a56dedc2287d466cda6febeb87f26c2"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#a8a56dedc2287d466cda6febeb87f26c2">beebScreen_GetFrameCounter</a> ()</td></tr>
<tr class="separator:a8a56dedc2287d466cda6febeb87f26c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4db2fec0f3095e1fc30e4d631368796"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="beeb_screen_8h.html#aa4db2fec0f3095e1fc30e4d631368796">beebScreen_ScanKey</a> (int key)</td></tr>
<tr class="separator:aa4db2fec0f3095e1fc30e4d631368796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>PiNativeArm and ARM7TDMI co-processor support library. beebScreen - A PiNativeArm and ARM7TDMI co-processor support library. This library provides a complete solution for taking an existing C code application or game which uses a linear frame buffer for it's output and converting that output into a format that can be displayed on the BBC Micro's own display. </p>
<p>To do this it provides functionality to convert the original video data into a format that will display on the BBC's screen, including either dithering to the default colour palette of the BBC Micro, or if a VideoNULA chip is installed to either a fixed or dynamic 16 colour palette from the NULAs 12bit RGB palette.</p>
<p>Also supported in the reading of both keyboard and mouse (provided the mouse supports the standard ADVAL 7,8 and 9 method of returning it's coordinates/buttons).</p>
<p>There is no sounds support in this library, althought it's still possible to call host sound functions via OS_Word to play sounds. </p><dl class="section author"><dt>Author</dt><dd>James Watson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/7/2021 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abc6133f35081bfe8289f0454d8095934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6133f35081bfe8289f0454d8095934">&#9670;&nbsp;</a></span>beebScreen_FindPalette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char beebScreen_FindPalette </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the index of the closest matching colour in the palette we're remapping to </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colour</td><td>- source colour to find </td></tr>
    <tr><td class="paramname">remap</td><td>- colours to remap to </td></tr>
    <tr><td class="paramname">total</td><td>- total number of colours in remap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>remapped colour index </dd></dl>

</div>
</div>
<a id="ac9b8644f8b9f87e01526a90e24bed77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b8644f8b9f87e01526a90e24bed77c">&#9670;&nbsp;</a></span>beebScreen_CreateRemapColours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_CreateRemapColours </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a map of indices to colour values to remap to a smaller palette </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- source colours to remap </td></tr>
    <tr><td class="paramname">remap</td><td>- colours to be remapped to </td></tr>
    <tr><td class="paramname">total</td><td>- total number of colours to remap to </td></tr>
    <tr><td class="paramname">len</td><td>- length of the source palette </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bdc30dd9c5a69a947bd2dc2ef849238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdc30dd9c5a69a947bd2dc2ef849238">&#9670;&nbsp;</a></span>beebScreen_SetDefaultNulaRemapColours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetDefaultNulaRemapColours </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a set of remap values to remap indices to the current nula palette Uses the set created with <a class="el" href="beeb_screen_8h.html#ac9b8644f8b9f87e01526a90e24bed77c">beebScreen_CreateRemapColours()</a> </p>

</div>
</div>
<a id="a1d19aa39ad7b8e154c57f23bd516ed72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d19aa39ad7b8e154c57f23bd516ed72">&#9670;&nbsp;</a></span>beebScreen_SetNulaRemapColours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetNulaRemapColours </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>remap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a set of remap values to remap indices to the current nula palette Uses a custom set of remap values, this array should be large enough for all the colours used in the current palette. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remap</td><td>- set of remap values to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaac1547bb293a41b29497e44e2d0dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaac1547bb293a41b29497e44e2d0dae">&#9670;&nbsp;</a></span>beebScreen_MakeNulaPal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beebScreen_MakeNulaPal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int v, int *r, int *g, int *b)&#160;</td>
          <td class="paramname"><em>extractor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an RGB palette into a NULA compatible palette entry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- RGB palette value </td></tr>
    <tr><td class="paramname">index</td><td>- NULA palette index </td></tr>
    <tr><td class="paramname">extractor</td><td>- extractor function to extract the RGB values from the palette value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b22300574e3650a3ca27662775d240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b22300574e3650a3ca27662775d240a">&#9670;&nbsp;</a></span>beebScreen_SetNulaPal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetNulaPal </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int v, int *r, int *g, int *b)&#160;</td>
          <td class="paramname"><em>extractor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets NULA palette values from RGB palette values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>- Array of palette entries </td></tr>
    <tr><td class="paramname">output</td><td>- Array to hold NULA palettes </td></tr>
    <tr><td class="paramname">count</td><td>- Number of entries </td></tr>
    <tr><td class="paramname">extractor</td><td>- Function to extract RGB values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb78b80a1d1b48a39cd9a6f23e934e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb78b80a1d1b48a39cd9a6f23e934e57">&#9670;&nbsp;</a></span>beebScreen_CreatePalMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beebScreen_CreatePalMap </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a remap array which maps a palette to the first occurance of each unique NULA palette entry, this is most useful when used in conjunction with <a class="el" href="beeb_screen_8h.html#af21e3b83d7ee0c6540a3cfd08645dc81">beebScreen_CreateDynamicPalette()</a> to help keep the palette entries to the minimum. This only needs to be called after a call to <a class="el" href="beeb_screen_8h.html#aaaac1547bb293a41b29497e44e2d0dae">beebScreen_MakeNulaPal()</a> when a program changes it's internal palette. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pal</td><td>- Palette to create map for </td></tr>
    <tr><td class="paramname">count</td><td>- Number of colours in the palette </td></tr>
    <tr><td class="paramname">map</td><td>- Array to write map into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unique colours found </dd></dl>

</div>
</div>
<a id="af21e3b83d7ee0c6540a3cfd08645dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21e3b83d7ee0c6540a3cfd08645dc81">&#9670;&nbsp;</a></span>beebScreen_CreateDynamicPalette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_CreateDynamicPalette </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>inPal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>palMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outPal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a dynamic palette from the current palette, also creates internal remap palette. This routine will try to assign colours in the existing internal palette to the same place where possible to minimise the changes between frames caused by the dynamic palette. Works best when combined with <a class="el" href="beeb_screen_8h.html#acb78b80a1d1b48a39cd9a6f23e934e57">beebScreen_CreatePalMap()</a> to create a map to unique palette colours in the current palette. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPal</td><td>- Source palette </td></tr>
    <tr><td class="paramname">palMap</td><td>- Remap from original palette to unique NULA colours </td></tr>
    <tr><td class="paramname">colours</td><td>- Number of colours in the original palette (not the remap) </td></tr>
    <tr><td class="paramname">outPal</td><td>- Target palette </td></tr>
    <tr><td class="paramname">target</td><td>- Number of target colours </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a171863033605e2dec8436d9d1f2778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a171863033605e2dec8436d9d1f2778">&#9670;&nbsp;</a></span>beebScreen_SendPal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SendPal </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a set of NULA palette values to the host, also required when using non-NULA mode to set the colours to map from for dithering in 2 colour and 16 colour modes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pal</td><td>- Array of palette entries </td></tr>
    <tr><td class="paramname">count</td><td>- Number of palette entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46ccceb770e35506381522ebe3484c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ccceb770e35506381522ebe3484c26">&#9670;&nbsp;</a></span>beebScreen_SetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current video mode for the host, Currently all graphics modes are supported, technically modes 3 and 6 are supported but since it won't remove the blank lines between character rows those will look a litte strange. Mode 7 is not supported :'( </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>- BBC Micro video mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd5f86ad4d6d4c17e74ee3f6d849f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd5f86ad4d6d4c17e74ee3f6d849f53">&#9670;&nbsp;</a></span>beebScreen_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_Init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialises the beebScreen library ready for use. Use the following flags to choose what to use:-</p><ul>
<li>BS_INIT_NORMAL - Single buffered, normal BBC palette.</li>
<li>BS_INIT_NULA - Use the VideoNULA for palette.</li>
<li>BS_INIT_DOUBLE_BUFFER - Create two frame buffers, note if there is not enough memory for both they will use the same memory space.</li>
<li>BS_INIT_MOUSE - Enables mouse support, your mouse should support reporting it's state via ADVAL 7,8 and 9.</li>
<li>BS_INIT_ADFS - Set if using ADFS to ensure that the frame buffers on the host don't overwrite ADFS workspace, generally you shouldn't need to do this. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>- BBC Micro Video Mode to use as the base </td></tr>
    <tr><td class="paramname">flags</td><td>- Flags to initialise </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="af48a5346b9833a8ac64770c3f47bca63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48a5346b9833a8ac64770c3f47bca63">&#9670;&nbsp;</a></span>beebScreen_InjectCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_InjectCode </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Injects 6502 code into the host's memory (can also inject data if required) Code injected can be assembled using BeebAsm, or any other compatible 6502 assembler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>- code/data to be injected </td></tr>
    <tr><td class="paramname">length</td><td>- size of code/data </td></tr>
    <tr><td class="paramname">dest</td><td>- destination address in the host's memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81b0585b650e3039c7e2287498dfc51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b0585b650e3039c7e2287498dfc51e">&#9670;&nbsp;</a></span>beebScreen_SetUserVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetUserVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets one of the 4 user vectors to point at user code on the host There are 4 vectors, USER1V, USER2V, VSYNCV and TIMERV</p><ul>
<li>BS_VECTOR_USER1 - is called when _VDU(BS_CMD_SEND_USER1) is called</li>
<li>BS_VECTOR_USER2 - is called when _VDU(BS_CMD_SEND_USER2) is called</li>
<li>BS_VECTOR_VSYNC - is called from the host's VSYNC interrupt routine</li>
<li>BS_VECTOR_TIMER - is called by the host's TIMER1 interrupt routine <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>- vector to set (BS_VECTOR_*) </td></tr>
    <tr><td class="paramname">addr</td><td>- Host address to set the vector to </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a82b214a7168d6e7f0b2cf1e796507cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b214a7168d6e7f0b2cf1e796507cf8">&#9670;&nbsp;</a></span>beebScreen_SetGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetGeometry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>setCrtc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the video mode size, can also set CRTC registers to reflect this geometry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- Width in pixels (must be a multiple of the modes character block size) </td></tr>
    <tr><td class="paramname">h</td><td>- Height in pixels (must be a multiple of 8) </td></tr>
    <tr><td class="paramname">setCrtc</td><td>- Set the CRTC registers so that the screen is centered on the display </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ce92b3447b64d431066bd4d6e055b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce92b3447b64d431066bd4d6e055b1b">&#9670;&nbsp;</a></span>beebScreen_SetScreenBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetScreenBase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the screen base address for front or back buffers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address of the screen buffer </td></tr>
    <tr><td class="paramname">secondBuffer</td><td>- set to TRUE to set the back buffer's address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f3faccb64a04961c67bcd6b47bba3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3faccb64a04961c67bcd6b47bba3ff">&#9670;&nbsp;</a></span>beebScreen_CalcScreenBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beebScreen_CalcScreenBase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secondBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the highest address that the current screen geometry can fit into, including space for double buffering if enabled </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondBuffer</td><td>- Calculate for the back buffer, allowing two screens of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a7552b5cb566badaecb3f578cfe3e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7552b5cb566badaecb3f578cfe3e8b">&#9670;&nbsp;</a></span>beebScreen_UseDefaultScreenBases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_UseDefaultScreenBases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the screenbase addresses to the defaults as calculated by beebScreen_CalcScreenBase. Calling this after calling <a class="el" href="beeb_screen_8h.html#a82b214a7168d6e7f0b2cf1e796507cf8">beebScreen_SetGeometry()</a> will setup the screen base addresses to sensible defaults based on the new size of the screen, note if you are double buffering it may not always be possible for it to allocate two buffers in the host's memory. If double buffer is set the both addresses will be calculated </p>

</div>
</div>
<a id="aff38476951488f8802720de1cc2c75ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff38476951488f8802720de1cc2c75ff">&#9670;&nbsp;</a></span>beebScreen_ClearScreens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_ClearScreens </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screenMemory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all the memory for both screen buffers both locally and on the host. Normally you would use this if the size of the two combined buffers is lower than the normal screen base address since this memory isn't cleared by a mode change.</p>
<p>Call after calling <a class="el" href="beeb_screen_8h.html#a82b214a7168d6e7f0b2cf1e796507cf8">beebScreen_SetGeometry()</a> and <a class="el" href="beeb_screen_8h.html#a8a7552b5cb566badaecb3f578cfe3e8b">beebScreen_UseDefaultScreenBases()</a> to clear screen memory that would normally not be cleared by changing modes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenMemory</td><td>- Clears all screen memory up to 0x8000 if true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d16bbfa1824fe755905a30490fcc01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d16bbfa1824fe755905a30490fcc01f">&#9670;&nbsp;</a></span>beebScreen_FlipCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_FlipCallback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a callback function called in the flip function to perform any custom updates you require after flipping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- pointer to callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaac6b2a3d6fd9f93dfe264bd9d34bf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac6b2a3d6fd9f93dfe264bd9d34bf6d">&#9670;&nbsp;</a></span>beebScreen_SetBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_SetBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the framebuffer data used for the non-beeb screen. The buffer should be a linear frame buffer when byte 0 is top left and the last byte the bottom right, running in rows from top to bottom, since this is the standard format for frame buffers used in modern software this isn't a particularly difficult requirement to fulfill. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the buffer </td></tr>
    <tr><td class="paramname">format</td><td>- format of the buffer (currently only BS_BUFFER_FORMAT_8BPP is supported) </td></tr>
    <tr><td class="paramname">w</td><td>- width of buffer in pixels </td></tr>
    <tr><td class="paramname">h</td><td>- height of buffer in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a822c1979c5a7d2361ef13663359655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a822c1979c5a7d2361ef13663359655">&#9670;&nbsp;</a></span>beebScreen_Flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_Flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compresses and transfers the current contents of the frame buffer to the BBC Micro's screen. This does the work, it converts the buffer data into a beeb screen format, does the delta compression with the previous frame (correctly works with double buffers) and sends the screen data to the beeb </p>

</div>
</div>
<a id="ad883835655aacdb8b0c3f5da47164da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad883835655aacdb8b0c3f5da47164da6">&#9670;&nbsp;</a></span>beebScreen_VSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_VSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for the next VSync, causes the internal frame counter value to be updated from the host </p>

</div>
</div>
<a id="ae232afaac80a1ab991ad7110d90bdc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae232afaac80a1ab991ad7110d90bdc52">&#9670;&nbsp;</a></span>beebScreen_Quit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_Quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuts down the system, removes vectors from the host side. It is safe to run another beebScreen application after exiting using <a class="el" href="beeb_screen_8h.html#ae232afaac80a1ab991ad7110d90bdc52">beebScreen_Quit()</a> </p>

</div>
</div>
<a id="a45543225bb0fdafe7d329cb8e3c4897a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45543225bb0fdafe7d329cb8e3c4897a">&#9670;&nbsp;</a></span>beebScreen_GetMouse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_GetMouse </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the last read mouse coordinates and button status, returns the middle of the screen if mouse isn't initialised or does not exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- address to hold X coordinate </td></tr>
    <tr><td class="paramname">y</td><td>- address to hold Y coordinate </td></tr>
    <tr><td class="paramname">b</td><td>- address to hold Buttons </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a531c1c4c57be869836c8aac929abf1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531c1c4c57be869836c8aac929abf1fa">&#9670;&nbsp;</a></span>beebScreen_ShowPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beebScreen_ShowPointer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>show</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells beebScreen if you want to show a virtual mouse pointer. Useful for projects that rely on the host having a hardware mouse pointer since the beeb doesn't have one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show</td><td>- should we show the pointer or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a56dedc2287d466cda6febeb87f26c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a56dedc2287d466cda6febeb87f26c2">&#9670;&nbsp;</a></span>beebScreen_GetFrameCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char beebScreen_GetFrameCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the host side internal frame counter, this runs from 0 to 255 and is incremented every vsync, you need to call <a class="el" href="beeb_screen_8h.html#ad883835655aacdb8b0c3f5da47164da6">beebScreen_VSync()</a> or <a class="el" href="beeb_screen_8h.html#a9a822c1979c5a7d2361ef13663359655">beebScreen_Flip()</a> for this value to be updated from the host's memory. </p><dl class="section return"><dt>Returns</dt><dd>frame counter from 0 to 255 </dd></dl>

</div>
</div>
<a id="aa4db2fec0f3095e1fc30e4d631368796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4db2fec0f3095e1fc30e4d631368796">&#9670;&nbsp;</a></span>beebScreen_ScanKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int beebScreen_ScanKey </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the chosen key has been pressed, a full list of keys is available in <a class="el" href="bbckeycodes_8h_source.html">bbckeycodes.h</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- key code to scan for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
